#!/usr/bin/env ruby

# xmlvalidate - validate an xml file with an xsd file (local files only)
# 
# There are three ways to call xmlvalidate. The first is the full/long
# form, the other two are convenient shorthands for the first:
# 
# Full Version:
# 
# xmlvalidate <xml> <xsd>
# - validates xml against xsd file.
# example:
#   xmlvalidate foo.xml schema.xsd
# 
# Shorthand 1: When xsd and xml files have the same name, differing
# only in .xml/.xsd extension:
# 
# xmlvalidate <object>
# - validates object.xml against object.xsd
# example:
#   xmlvalidate foo/bar/baz
# same as => xmlvalidate foo/bar/baz.xml foo/bar/baz.xsd
#
# Shorthand 2: When validating xsd/xml in api_mapper folders
# (app-specific, sorry), where examples are stored in
# public/examples/{version}/{object}.xml and schemas are stored in
# public/versions/{version}/{object}.xsd:
# 
# xmlvalidate <version> <object>
# e.g. xmlvalidate 2.0.0 decision
# => is the same as:
# xmlvalidate public/examples/2.0.0/decision.xml public/versions/2.0.0/decision.xsd
# 
# TODO: Validate against a public (http) schema?
# TODO: If the xml doc has public schema info in it, validate against that?
require 'xml'

errors = []
args = ARGV.dup

# Detect first shorthand
if args.size == 1
  args = [ args.first + ".xml", args.first + ".xsd" ]
else
  # Detect second form of args 
  if args.first =~ /^(\d+\.)+\d+/
    args = [ "public/examples/#{args.first}/#{args.last}.xml", "public/versions/#{args.first}/#{args.last}.xsd"]
  end
end

document = LibXML::XML::Document.file(args.first)

schema = LibXML::XML::Schema.new(args.last)
result = document.validate_schema(schema) do |message,flag|
  errors << message
end

if errors.length > 0
  puts "#{args.first} contains errors:"
  puts errors.map {|e| "ERROR: #{e}"}
else
  puts "#{args.first} validates ok according to its schema."
end

exit errors.length

